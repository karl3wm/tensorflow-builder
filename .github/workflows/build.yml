name: Build
on:
  workflow_dispatch: # Allows manual triggering from the Actions tab
  schedule: # Example: Run weekly on Sunday at 03:00 UTC
    - cron: '0 3 * * 0'
  push:
    branches:
      - main
    paths:
      - '.github/workflows/**' # Only run if workflow files change
jobs:
  recent_tensorflow_tags:
    runs-on: ubuntu-latest
    outputs:
      versions: ${{ steps.tensorflow_latest.outputs.versions }}
    # strategy:
    #   matrix:
    #     tensorflow_latest: [1, 2, 3, 4, 5, 6, 7, 8]
    steps:
      - name: Install jq
        run: sudo apt-get install jq coreutils git
      - name: Fetch recent TensorFlow tags
        id: tensorflow_latest
        run: |
          mkdir -p tensorflow
          cd tensorflow
          git init .
          git remote add origin https://github.com/tensorflow/tensorflow
          git fetch --filter=tree:0 origin
          echo "versions=$(git tag --list --sort=-creatordate 'v*.[0-9]' | head -n 16 | jq -R -s -c 'rtrimstr("\n")|split("\n")')" | tee -a $GITHUB_OUTPUT
          #ref="$(git tag --list --sort=-creatordate 'v*.[0-9]' | head -n ${{ matrix.tensorflow_latest }} | tail -n 1)"
          ##ref="$(git ls-remote --quiet --tags --sort=-creatordate https://github.com/tensorflow/tensorflow 'v*.[0-9]' | head -n ${{ matrix.tensorflow_latest }} | tail -n 1 | cut -f 2)"
          #echo "Selected TensorFlow $ref"
          #echo "version=${ref#v}" >> $GITHUB_OUTPUT
  build:
    runs-on: ubuntu-latest
    needs: recent_tensorflow_tags
    timeout-minutes: 360 # 6 hours (GitHub Actions maximum for free tier)
    strategy:
      fail-fast: false
      matrix:
        python: ['3.11', '3.12']
        tensorflow: ${{ fromJSON(needs.recent_tensorflow_tags.outputs.versions) }}
    steps:
      - name: Set up Python ${{ matrix.python }}
        id: setup_python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python }}
      - name: Checkout TensorFlow ${{ matrix.tensorflow }}
        working-directory: tensorflow
        run: |
          git checkout ${{ matrix.tensorflow }} -b build
      # - name: Checkout TensorFlow Source Code
      #   uses: actions/checkout@v4
      #   with:
      #     repository: 'tensorflow/tensorflow'
      #     path: 'tensorflow'
      #     filter: 'blob:none'
      #     ref: ${{ matrix.tensorflow }}
      # - name: Check out ${{ matrix.tensorflow_latest }}-most recent tensorflow tag
      #   id: checkout
      #   working-directory: tensorflow
      #   run: |
      #     TF_REF="$(git tag --list --sort=-creatordate 'v*.[0-9]' | head -n ${{ matrix.tensorflow_latest }} | tail -n 1)"
      #     git checkout "$TF_REF"
      #     echo "TF_VERSION=${TF_REF#v}" >> $GITHUB_OUTPUT
      # # These outputs are used later in the run
      # - name: Generate values available at runtime
      #   id: generated
      #   working-directory: ./tensorflow
      #   run: |
      #     echo "PYTHON_BIN_PATH=$(which python)" >> $GITHUB_OUTPUT
      #     echo "PYTHON_LIB_PATH=$(python -c 'import site; print(site.getsitepackages()[0])')" >> $GITHUB_OUTPUT
      #     echo "TF_PYTHON_VERSION=$(python -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')" >> $GITHUB_OUTPUT
      #     TF_REF="$(git tag --list --sort=-creatordate 'v*.[0-9]' | head -n ${{ matrix.tensorflow_latest }} | tail -n 1)"
      #     git checkout "$TF_REF"
      #     echo "TF_VERSION=${TF_REF#v}" >> $GITHUB_OUTPUT
      # - name: Determine Bazel Version
      #   id: bazel_version
      #   working-directory: ./tensorflow
      #   run: |
      #     if [[ -f ".bazelversion" ]]; then
      #       BAZEL_VERSION_FROM_FILE=$(cat .bazelversion | head -n 1)
      #       echo "Found .bazelversion, using Bazel version: $BAZEL_VERSION_FROM_FILE"
      #       echo "bazel_version=$BAZEL_VERSION_FROM_FILE" >> $GITHUB_OUTPUT
      #     else
      #       # --- Fallback Bazel Version ---
      #       # Choose a version known to work with recent TF if .bazelversion is missing
      #       DEFAULT_BAZEL_VERSION="6.1.0"
      #       echo "WARN: .bazelversion not found in TF source for tag v${{ steps.checkout.outputs.TF_VERSION }}."
      #       echo "Using fallback Bazel version: $DEFAULT_BAZEL_VERSION"
      #       echo "bazel_version=$DEFAULT_BAZEL_VERSION" >> $GITHUB_OUTPUT
      #     fi
      - name: Install Build Dependencies
        run: |
          echo "set man-db/auto-update false" | sudo debconf-communicate
          sudo dpkg-reconfigure man-db
          #sudo apt-get remove --yes --quiet firefox
          #sudo apt-get remove --yes --quiet firefox clang*
          #sudo apt-get update --yes --quiet
          #sudo apt-get dist-upgrade --yes --quiet # slows down build
          sudo apt-get install --yes --quiet build-essential curl git python3-dev pkg-config zip unzip clang lld wget sed
          echo "Attempting to install latest Bazelisk"
          mkdir -p $HOME/bin
          wget --progress=dot:mega https://github.com/bazelbuild/bazelisk/releases/latest/download/bazelisk-linux-amd64 -O $HOME/bin/bazel
          chmod +x $HOME/bin/bazel
          # Add to PATH for subsequent steps
          echo "$HOME/bin" >> $GITHUB_PATH
          echo "Bazel installation complete."
          type -p bazel
      - name: Restore Bazel Cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/.cache/bazel
            ~/.cache/bazelisk
            tensorflow/build_output/cache
          key: bazel-cache-os${{ runner.os }}-tf${{ matrix.tensorflow }}-py${{ steps.setup_python.outputs.python-version }}-bazel${{ steps.bazel_version.outputs.bazel_version }}-run
      # - name: Dump Configuration and Environment (Troubleshooting)
      #   run: |
      #     echo "--- System Info ---"
      #     uname -a
      #     lsb_release -a
      #     echo "--- Tool Versions ---"
      #     python --version
      #     pip --version
      #     bazel version || echo "Bazel not found or failed"
      #     gcc --version || echo "GCC not found or failed"
      #     g++ --version || echo "G++ not found or failed"
      #     clang --version || echo "Clang not found or failed"
      #     ldd --version || echo "ldd not found or failed" # GNU ld version
      #     ld.lld --version || echo "ld.lld not found or failed" # LLVM linker version
      #     echo "--- Key Environment Variables ---"
      #     echo "PATH=$PATH"
      #     echo "PYTHON_BIN_PATH=${{ steps.generated.outputs.PYTHON_BIN_PATH }}"
      #     echo "PYTHON_LIB_PATH=${{ steps.generated.outputs.PYTHON_LIB_PATH }}"
      #     echo "TF_PYTHON_VERSION=${{ steps.generated.outputs.TF_PYTHON_VERSION }}"
      #     printenv | grep TF_ || echo "No TF_ environment variables set yet"
      #     printenv | grep CC_ || echo "No CC_ environment variables set yet"
      #     echo "--- Python Site Packages ---"
      #     ls -l ${{ steps.generated.outputs.PYTHON_LIB_PATH }} || echo "Could not list site-packages"
      # ---------------------------------------------------------------------
      # Tmate Debugging Step - uncomment/comment as needed
      # This will pause the workflow and output SSH connection details
      # Connect to the runner to manually inspect the environment and run commands
      # - name: Setup tmate session for debugging
      #   uses: mxschmitt/action-tmate@v3
      #   timeout-minutes: 60
      # ---------------------------------------------------------------------
      - name: Configure and build TensorFlow
        id: build
        working-directory: ./tensorflow
        # env:
        #   # Environment variables for TensorFlow's configure script (non-interactive)
        #   PYTHON_BIN_PATH: ${{ steps.generated.outputs.PYTHON_BIN_PATH }}
        #   PYTHON_LIB_PATH: ${{ steps.generated.outputs.PYTHON_LIB_PATH }}
        #   TF_PYTHON_VERSION: ${{ steps.generated.outputs.TF_PYTHON_VERSION }}
        #   TF_ENABLE_XLA: '1'
        #   TF_NEED_CUDA: '0'
        #   TF_NEED_ROCM: '0'
        #   # Let Bazel decide on Clang download/use by default
        #   # TF_DOWNLOAD_CLANG: '0'
        #   # Remove explicit GCC paths to allow Bazel to potentially pick Clang
        #   # GCC_HOST_COMPILER_PATH: /usr/bin/gcc
        #   # HOST_CXX_COMPILER_PATH: /usr/bin/g++
        #   TF_CONFIGURE_IOS: '0'
        #   TF_SET_ANDROID_WORKSPACE: '0'
        #   # --- CRUCIAL: Compiler flags to disable AVX/AVX2 ---
        #   # Target Nehalem (SSE4.2 baseline before AVX). Adjust if needed.
        #   CC_OPT_FLAGS: '-march=nehalem -mno-avx -mno-avx2 -O3'
        #   TF_BUILD_FLAGS: "--config=monolithic --config=opt --copt=-march=nehalem --copt=-mno-avx --copt=-mno-avx2 --copt=-O3 --verbose_failures" # --toolchain_resolution_debug=@bazel_tools//tools/cpp:toolchain_type --subcommands # Build the pip package with enhanced verbosity
        #   TF_NEED_OPENCL_SYCL: '0'
        #   TF_NEED_COMPUTECPP: '0'
        #   TF_NEED_MPI: '0'
        #   TF_NEED_TENSORRT: '0'
        #   CONTAINER_TYPE: cpu # cpu gpu rocm
        #   OS_TYPE: ubuntu # ubuntu macos
        #   IS_NIGHTLY: 0
        #   TF_PROJECT_NAME: "tensorflow_noavx"
        #   KOKORO_ARTIFACTS_DIR: ../tmp
        #   TF_TEST_FLAGS: "--verbose_failures=true --build_tests_only --test_output=errors"
        #   TF_TEST_FILTER_TAGS: "-no_oss,-oss_excluded,-oss_serial,-gpu,-tpu,-benchmark-test"
        #   TF_TEST_TARGETS: "//tensorflow/... -//tensorflow/compiler/... -//tensorflow/contrib/..."
        #   #HERMETIC_PYTHON_VERSION: ${{ steps.generated.outputs.TF_PYTHON_VERSION }}
        #   #WHEEL_NAME: tensorflow_noavx_cpu
        run: |
          echo "TFCI_PYTHON_VERSION=$(python -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")')" > ci/official/envs/py_custom
          echo 'TFCI_BAZEL_COMMON_ARGS="$TFCI_BAZEL_COMMON_ARGS --config=monolithic --copt=-march=nehalem --copt=-mno-avx --copt=-mno-avx2 --copt=-O3 --verbose_failures"' > ci/official/envs/noavx_custom
          echo 'TFCI_BUILD_PIP_PACKAGE_WHEEL_NAME_ARG="${TFCI_BUILD_PIP_PACKAGE_WHEEL_NAME_ARG/tensorflow/tensorflow_noavx}"' >> ci/official/envs/noavx_custom
          echo 'TFCI_INSTALLER_WHL_PROJECT_NAME="${TFCI_INSTALLER_WHL_PROJECT_NAME/tensorflow/tensorflow_noavx}"' >> ci/official/envs/noavx_custom
          for envfile in py_custom linux_x86 disk_cache no_docker noavx_custom
          do
                echo "$envfile":
                cat ci/official/envs/"$envfile"
          done
          echo "Running Bazel build and creating wheel file ..."
          TFCI=py_custom,linux_x86,disk_cache,no_docker,noavx_custom ci/official/wheel.sh
          # echo "Running ./configure with environment variables:"
          # printenv | grep TF_ # Show TF vars being used
          # printenv | grep CC_OPT_FLAGS # Show compiler flags being used
          # ./configure
          # echo "Configure finished."
          # echo "Migrating build_pip_package vs build_pip_package_py ..."
          #
          # find -name build_pip_package.py && sed -i 's!PIP_BUILD_TARGET="//tensorflow/tools/pip_package:build_pip_package"!PIP_BUILD_TARGET="//tensorflow/tools/pip_package:build_pip_package_py"!' tensorflow/tools/ci_build/builds/pip_new.sh
          # . tensorflow/tools/ci_build/builds/pip_new.sh
          #
          # #echo "Bazel build finished. Creating wheel file..."
          # ## Create the wheel package in /tmp/tensorflow_pkg (relative to workspace root)
          # #./bazel-bin/tensorflow/tools/pip_package/build_pip_package --cpu ../tmp/tensorflow_pkg
          #
          # echo "Wheel file created in ${PIP_WHL_DIR}:"
          echo "Bazel build finished and wheel file created in build_output:"
          ls build_output/*.whl
          echo PIP_WHL_DIR="$(pwd)/build_output" >> $GITHUB_OUTPUT
      - name: Always Save Bazel Cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: |
            ~/.cache/bazel
            ~/.cache/bazelisk
            tensorflow/build_output/cache
          key: bazel-cache-os${{ runner.os }}-tf${{ matrix.tensorflow }}-py${{ steps.setup_python.outputs.python-version }}-bazel${{ steps.bazel_version.outputs.bazel_version }}-run{{github.run_id}.{{github.run_attempt}}
      - name: Upload TensorFlow Wheel Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tensorflow-noavx-tf${{ matrix.tensorflow }}-py${{ steps.setup_python.outputs.python-version }}
          # Path is relative to the workspace root
          path: ${{ steps.build.outputs.PIP_WHL_DIR }}/*.whl
          retention-days: 7
  # Optional: Job to create a GitHub Release and upload the wheel there
  release:
    needs: build
    runs-on: ubuntu-latest
    if: success() && (github.event_name == 'workflow_dispatch') # Only release on successful manual runs for now
    steps:
      - name: Download wheel artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: tensorflow-noavx-tf${{ matrix.tensorflow }}-py${{ steps.setup_python.outputs.python-version }}
          path: dist
      - name: Display structure of downloaded files
        run: ls -R dist
      - name: Create GitHub Release and Upload Wheel
        uses: softprops/action-gh-release@v1
        with:
          tag_name: tf-v${{ matrix.tensorflow }}-noavx-py${{ steps.setup_python.outputs.python-version }}-build${{ github.run_id }}
          name: TensorFlow ${{ matrix.tensorflow }} (No AVX) for Python ${{ matrix.python }}
          body: |
            TensorFlow wheel built from source without AVX/AVX2 instructions.
            TensorFlow Version: ${{ matrix.tensorflow }}
            Python Version: ${{ steps.setup_python.outputs.python-version }}
            Target Architecture Flags: -march=nehalem -mno-avx -mno-avx2
            Built via GitHub Actions run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            Bazel Version Used: ${{ needs.build.outputs.bazel_version }} # Needs output from build job
          files: dist/*.whl
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  publish-to-pages:
    needs: build # Run only after the build job succeeds
    runs-on: ubuntu-latest
    # Only publish on manual triggers or scheduled runs that succeed
    if: success() && (github.event_name == 'workflow_dispatch' || github.event_name == 'schedule')
    # Grant permissions for actions/checkout to push to gh-pages branch
    permissions:
      contents: write
    steps:
      - name: Download wheel artifact from build job
        uses: actions/download-artifact@v4
        with:
          # Must match the upload name in the 'build' job
          name: tensorflow-noavx-${{ matrix.tensorflow }}-py${{ steps.setup_python.outputs.python-version }}
          # Download to a temporary directory
          path: ./wheel-artifact
      - name: List downloaded artifact contents
        run: ls -R ./wheel-artifact
      - name: Checkout GitHub Pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages # The branch to publish to
          path: gh-pages # Checkout to a specific directory
      - name: Set up Python (for potential scripting)
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - name: Create PEP 503 structure and update index
        shell: bash # Use bash for scripting
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.

          # Define directories relative to the checked-out gh-pages directory
          PAGES_DIR="gh-pages"
          SIMPLE_DIR="$PAGES_DIR/simple"
          PKG_DIR="$SIMPLE_DIR/tensorflow" # Package name is 'tensorflow'

          echo "Ensuring package directory exists: $PKG_DIR"
          mkdir -p "$PKG_DIR"

          echo "Moving wheel file(s)..."
          # Find the wheel file (handle potential multiple wheels if matrix is used later)
          find ./wheel-artifact -name "*.whl" -exec mv {} "$PKG_DIR/" \;

          echo "Generating simple index: $SIMPLE_DIR/index.html"
          # This index just needs to list the package names available
          cat <<EOF > "$SIMPLE_DIR/index.html"
          <!DOCTYPE html>
          <html>
            <head>
              <title>Simple Index</title>
            </head>
            <body>
              <a href="tensorflow/">tensorflow</a><br />
            </body>
          </html>
          EOF

          echo "Generating package index: $PKG_DIR/index.html"
          # This index lists all the wheel files for the 'tensorflow' package
          # Important: Links must be relative to the index file itself
          echo '<!DOCTYPE html><html><head><title>Links for tensorflow</title></head><body><h1>Links for tensorflow</h1>' > "$PKG_DIR/index.html"
          for filename in "$PKG_DIR"/*.whl; do
            # Extract just the filename for the link text and href
            wheel_name=$(basename "$filename")
            echo "Found wheel: $wheel_name"
            # Append link to the index file
            echo "<a href=\"$wheel_name\">$wheel_name</a><br />" >> "$PKG_DIR/index.html"
          done
          echo '</body></html>' >> "$PKG_DIR/index.html"

          echo "Index files generated."
          ls -lR "$PAGES_DIR"
      - name: Commit and push changes to gh-pages
        run: |
          cd gh-pages
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          # Add all changes (new wheels, updated index files)
          git add .
          # Commit only if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Add/update TensorFlow wheel(s) and index [skip ci]"
            git push origin gh-pages
            echo "Changes pushed to gh-pages branch."
          fi
